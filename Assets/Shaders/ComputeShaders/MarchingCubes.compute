// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel MarchingCubes
#include "MarchingCubesTable.compute"

struct Triangle {
    float3 a;
    float3 b;
    float3 c;
};

AppendStructuredBuffer<Triangle> triangles;
RWStructuredBuffer<float> corners;
float scale;

int indexFromCoords(int x, int y, int z) {
    return z + y * 64 + x * 64 * 64;
}

float3 caseToRealWorld(float3 vertice, uint3 id) {
    return (vertice + id) / 63 * 64;
}

[numthreads(8,8,8)]
void MarchingCubes(uint3 id : SV_DispatchThreadID)
{
	if (id.x >= 64-1 || id.y >= 64-1 || id.z >= 64-1)
	{
		return;
	}

	float cubeCorners[8] =
	{
		corners[indexFromCoords(id.x, id.y, id.z)],
		corners[indexFromCoords(id.x + 1, id.y, id.z)],
		corners[indexFromCoords(id.x + 1, id.y, id.z + 1)],
		corners[indexFromCoords(id.x, id.y, id.z + 1)],
		corners[indexFromCoords(id.x, id.y + 1, id.z)],
		corners[indexFromCoords(id.x + 1, id.y + 1, id.z)],
		corners[indexFromCoords(id.x + 1, id.y + 1, id.z + 1)],
		corners[indexFromCoords(id.x, id.y + 1, id.z + 1)]
	};

	int caseIndex = 0;
	if (cubeCorners[0] > 0.0)
		caseIndex += 1;
	if (cubeCorners[1] > 0.0)
		caseIndex += 2;
	if (cubeCorners[2] > 0.0)
		caseIndex += 4;
	if (cubeCorners[3] > 0.0)
		caseIndex += 8;
	if (cubeCorners[4] > 0.0)
		caseIndex += 16;
	if (cubeCorners[5] > 0.0)
		caseIndex += 32;
	if (cubeCorners[6] > 0.0)
		caseIndex += 64;
	if (cubeCorners[7] > 0.0)
		caseIndex += 128;

	float3 mCCase[15] = configurations[caseIndex];

	float3 currentCase;
	for (uint i = 0; i < 15; i += 3)
	{
		if (mCCase[i].x < 0.0)
		{
			break;
		}

		float3 a = mCCase[i];
		float3 b = mCCase[i + 1];
		float3 c = mCCase[i + 2];

		Triangle tri;

		tri.a = caseToRealWorld(a, id);
		tri.b = caseToRealWorld(b, id);
		tri.c = caseToRealWorld(c, id);

		triangles.Append(tri);
	}
}